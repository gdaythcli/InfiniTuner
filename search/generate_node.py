from search.search_utils import Node
import re
import os
import utils.constants as constants
import configparser
from utils.filter import key_filter, BLACKLIST, DB_BENCH_ARGS

def dict_to_configparser(dictionary):
    '''
    Function to convert a dictionary to a configparser object

    Parameters:
    - dictionary (dict): The dictionary to be converted

    Returns: 
    - config (configparser.ConfigParser): The configparser object
    '''
    config = configparser.ConfigParser()

    for section, options in dictionary.items():
        config[section] = {}
        for key, value in options.items():
            config[section][key] = value

    return config

def configparser_to_string(config_parser):
    '''
    Function to convert a configparser object to a string

    Parameters:
    - config_parser (configparser.ConfigParser): The configparser object

    Returns:
    - string_representation (str): The string representation of the configparser object
    '''
    string_representation = ''
    for section in config_parser.sections():
        string_representation += f"[{section}]\n"
        for key, value in config_parser[section].items():
            key = key_filter(key)
            string_representation += f"  {key}={value}\n"
        string_representation += '\n'
    return string_representation

def parse_db_bench_args_to_dict(db_bench_args):
    '''
    Function to parse the db_bench arguments to a dictionary

    Parameters:
    - db_bench_args (list): The db_bench arguments

    Returns:
    - parsed (dict): A dictionary containing the parsed data
    '''
    parsed = {}
    for db_bench_arg in db_bench_args:
        key, value = db_bench_arg.strip().strip("--").split("=")
        parsed[key] = value
    return parsed

def parse_gpt_text_to_dict(gpt_output_text):
    '''
    Function to parse the gpt output text with filters

    Parameters:
    - gpt_output_text (str): The output generated by gpt

    Returns:
    - options_dict (dict): A dictionary containing the parsed data
    '''

    options_dict = {}

    for line in gpt_output_text.split("\n"):
        # Ignore lines starting with '#' as they are comments
        if not line.startswith('#'):
            # Split the line at the first '=' and strip whitespace
            parts = line.split(':', 1)
            if len(parts) == 1:
                parts = line.split('=', 1)
            if len(parts) == 2:
                # filters options that start with { - k
                if '{' not in parts[1].strip():
                    # filters options that are in the blacklist
                    if parts[0].strip() not in BLACKLIST:
                        key, value = parts[0].strip().strip("--"), parts[1].strip().split('#')[0].strip()
                        options_dict[key] = value

    return options_dict

def parse_option_file_to_dict(option_file):
    '''
    Function to parse the given option file to a dictionary

    Parameters:
    - option_file (str): The path to the option file

    Returns:
    - parsed (dict): A dictionary containing the parsed data
    '''
    pat = re.compile("(.*)\s*([#].*)?")
    config = configparser.ConfigParser()
    config.read_string(option_file)
    parsed = {section: dict(config.items(section))
              for section in config.sections()}
    for section_name, section in parsed.items():
        for k, v in section.items():
            m = pat.match(v)
            section[k] = m[1]
    return parsed

def cleanup_options_file_node(gpt_options_text, prev_db_bench_args, opt_file_path):
    """
    Function to clean up the options file generated by GPT
    - replace the values of the options in the original options file with the values generated by GPT-4
        eliminate 2 secnarios:
        1. ```ini<code>```
        2. ```<code>...``` w/ multiple code blocks

    Parameters:
    - gpt_options_text: string containing the options file generated by GPT-4

    Returns:
    - config_string: string containing the options file in the original format
    """
    clean_output_dict = parse_option_file_to_dict(open(f"{constants.OPTIONS_FILE_DIR}").read())

    # Parse the GPT-4 generated options
    gpt_output_dict = parse_gpt_text_to_dict(gpt_options_text)

    # Changed value
    changed_value = {}

    args_dict = parse_db_bench_args_to_dict(prev_db_bench_args)

    # Update the original options with GPT-4 generated value
    for key, value in gpt_output_dict.items():
        if key in DB_BENCH_ARGS:
            if value == "-1":
                continue
            if key not in args_dict or args_dict[key] != value:
                args_dict[key] = value
                changed_value[key] = value
            continue
        
        for internal_dict in clean_output_dict:
            if key in clean_output_dict[internal_dict]:
                if clean_output_dict[internal_dict][key] != gpt_output_dict[key]:
                    clean_output_dict[internal_dict][key] = gpt_output_dict[key]
                    changed_value[key] = gpt_output_dict[key]
                    break
                # else:
                #     same value
                #     log_update()
            # else:
            #     log_update(f"Key: {key} is not an RocksDB options")

    # Convert dictionary to configparser
    config_parser = dict_to_configparser(clean_output_dict)
    config_string = configparser_to_string(config_parser)
    new_bench_args = [f"--{k}={v}" for k, v in args_dict.items()]

    # Save to a file
    with open(opt_file_path, "w") as file:
        file.write(config_string)
    return config_string, changed_value, new_bench_args

def generate_node(response):
    """
    Generate a node from the response of the GPT-4 API
    
    Args:
        response (string): The response from the GPT-4 API.
    
    Returns:
        Node: The node generated from the response.
    """
    pattern = re.compile(r"```([\s\S]*?)```")
    matches = pattern.findall(response)
    if len(matches) != 6:
        raise ValueError("Expected exactly six blocks of content.")
    # Extract the child options and their reasoning
    nodes = []
    for i in range(0, 6, 2):
        option = matches[i]
        reasoning = matches[i + 1]
        node = Node(option=option, reasoning=reasoning)
        base_dir = os.path.dirname(constants.OPTIONS_FILE_DIR)
        child_opt_file = f"{node.id}.ini"
        clean_options_file, changed_value_dict, db_bench_args = cleanup_options_file_node(option, [], os.path.join(base_dir, child_opt_file))
        node.clean_options = clean_options_file
        node.file_path = os.path.join(base_dir, child_opt_file)
        nodes.append(node)

    return nodes