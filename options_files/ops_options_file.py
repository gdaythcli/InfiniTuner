import os
import re
import configparser
from abstraction.abstraction import convert_options_to_rocksdb
from utils.constants import ABSTRACTION, DEFAULT_OPTION_FILE_DIR, INITIAL_OPTIONS_FILE_NAME, OPTIONS_FILE_DIR
from utils.filter import BLACKLIST, DB_BENCH_ARGS
from utils.parse import dict_to_configparser, configparser_to_string
from utils.utils import log_update
from utils.color_logger import logger

def parse_gpt_text_to_dict(gpt_output_text):
    '''
    Function to parse the gpt output text with filters

    Parameters:
    - gpt_output_text (str): The output generated by gpt

    Returns:
    - options_dict (dict): A dictionary containing the parsed data
    '''
    if ABSTRACTION:
        gpt_output_text = convert_options_to_rocksdb(gpt_output_text)

    options_dict = {}

    for line in gpt_output_text.split("\n"):
        # Ignore lines starting with '#' as they are comments
        if not line.startswith('#'):
            # Split the line at the first '=' and strip whitespace
            parts = line.split(':', 1)
            if len(parts) == 1:
                parts = line.split('=', 1)
            if len(parts) == 2:
                # filters options that start with { - k
                if '{' not in parts[1].strip():
                    # filters options that are in the blacklist
                    if parts[0].strip() not in BLACKLIST:
                        key, value = parts[0].strip().strip("--"), parts[1].strip().split('#')[0].strip()
                        options_dict[key] = value

    return options_dict

def cleanup_options_file(gpt_options_text, prev_db_bench_args):
    """
    Function to clean up the options file generated by GPT
    - replace the values of the options in the original options file with the values generated by GPT-4
        eliminate 2 secnarios:
        1. ```ini<code>```
        2. ```<code>...``` w/ multiple code blocks

    Parameters:
    - gpt_options_text: string containing the options file generated by GPT-4

    Returns:
    - config_string: string containing the options file in the original format
    """
    clean_output_dict = parse_option_file_to_dict(open(f"{OPTIONS_FILE_DIR}").read())

    # Parse the GPT-4 generated options
    gpt_output_dict = parse_gpt_text_to_dict(gpt_options_text)

    # Changed value
    changed_value = {}

    args_dict = parse_db_bench_args_to_dict(prev_db_bench_args)

    # Update the original options with GPT-4 generated value
    for key, value in gpt_output_dict.items():
        if key in DB_BENCH_ARGS:
            if value == "-1":
                continue
            if key not in args_dict or args_dict[key] != value:
                args_dict[key] = value
                changed_value[key] = value
            continue
        
        for internal_dict in clean_output_dict:
            if key in clean_output_dict[internal_dict]:
                if clean_output_dict[internal_dict][key] != gpt_output_dict[key]:
                    clean_output_dict[internal_dict][key] = gpt_output_dict[key]
                    changed_value[key] = gpt_output_dict[key]
                    break
                # else:
                #     same value
                #     log_update()
            # else:
            #     log_update(f"Key: {key} is not an RocksDB options")

    # Convert dictionary to configparser
    config_parser = dict_to_configparser(clean_output_dict)
    config_string = configparser_to_string(config_parser)
    new_bench_args = [f"--{k}={v}" for k, v in args_dict.items()]

    # Save to a file
    with open(f"{OPTIONS_FILE_DIR}", "w") as file:
        file.write(config_string)
    return config_string, changed_value, new_bench_args

def cleanup_options_file_node(gpt_options_text, prev_db_bench_args, opt_file_path):
    """
    Function to clean up the options file generated by GPT
    - replace the values of the options in the original options file with the values generated by GPT-4
        eliminate 2 secnarios:
        1. ```ini<code>```
        2. ```<code>...``` w/ multiple code blocks

    Parameters:
    - gpt_options_text: string containing the options file generated by GPT-4

    Returns:
    - config_string: string containing the options file in the original format
    """
    clean_output_dict = parse_option_file_to_dict(open(f"{OPTIONS_FILE_DIR}").read())

    # Parse the GPT-4 generated options
    gpt_output_dict = parse_gpt_text_to_dict(gpt_options_text)

    # Changed value
    changed_value = {}

    args_dict = parse_db_bench_args_to_dict(prev_db_bench_args)

    # Update the original options with GPT-4 generated value
    for key, value in gpt_output_dict.items():
        if key in DB_BENCH_ARGS:
            if value == "-1":
                continue
            if key not in args_dict or args_dict[key] != value:
                args_dict[key] = value
                changed_value[key] = value
            continue
        
        for internal_dict in clean_output_dict:
            if key in clean_output_dict[internal_dict]:
                if clean_output_dict[internal_dict][key] != gpt_output_dict[key]:
                    clean_output_dict[internal_dict][key] = gpt_output_dict[key]
                    changed_value[key] = gpt_output_dict[key]
                    break
                # else:
                #     same value
                #     log_update()
            # else:
            #     log_update(f"Key: {key} is not an RocksDB options")

    # Convert dictionary to configparser
    config_parser = dict_to_configparser(clean_output_dict)
    config_string = configparser_to_string(config_parser)
    new_bench_args = [f"--{k}={v}" for k, v in args_dict.items()]

    # Save to a file
    with open(opt_file_path, "w") as file:
        file.write(config_string)
    return config_string, changed_value, new_bench_args

def cleanup_options_file_node_with_structured_change(changed_options, prev_db_bench_args, opt_file_path, changed_db_bench_args=None):
    """
    Updates the original ini configuration file based on a structured change object and returns the updated configuration string,
    a dictionary of changed options, and a new list of bench arguments.
    
    Parameters:
      changed_options: an object representing the changes, typically an instance of INIConfig (or an Action object with a 'changed' field).
                       Its attributes include:
                         - Version
                         - DBOptions
                         - CFOptions
                         - TableOptionsBlockBasedTable
                       Each attribute is either a string (with "key=value" entries separated by newlines) or a list of strings.
      prev_db_bench_args: previous db_bench arguments (as a string), e.g., "--key=value ...".
      opt_file_path: the file path where the updated configuration should be written.
    
    Returns:
      config_string: the updated configuration file text (in ini format).
      changed_value: a dictionary that records which options have been updated (keys are option names, values are the updated values).
      new_bench_args: a list of new bench arguments in the format ["--key=value", ...].
    """
    # Read the original configuration file (assuming OPTIONS_FILE_DIR is the configuration file path)
    with open(f"{OPTIONS_FILE_DIR}", "r") as f:
        original_text = f.read()
    # Parse the configuration file into a dictionary of the form { section_name: { key: value, ... }, ... }
    clean_output_dict = parse_option_file_to_dict(original_text)
    
    # Parse the db_bench arguments
    args_dict = parse_db_bench_args_to_dict(prev_db_bench_args)
    # Dictionary to record all changed options
    changed_value = {}

    # Mapping from the structured object's attributes to the actual ini file section names
    section_map = {
        "Version": "Version",
        "DBOptions": "DBOptions",
        "CFOptions": 'CFOptions "default"',
        "TableOptionsBlockBasedTable": 'TableOptions/BlockBasedTable "default"'
    }

    # Iterate over each section in the structured change object to update the configuration
    for attr, section in section_map.items():
        # Get the value of the attribute; if None, it indicates no changes for this section
        value = getattr(changed_options, attr, None)
        if value is None:
            continue

        # Convert the value into a list of lines.
        # If the value is a string, split by newlines; if it is already a list, use it directly.
        if isinstance(value, str):
            lines = [line.strip() for line in value.strip().splitlines() if line.strip()]
        elif isinstance(value, list):
            lines = [line.strip() for line in value if line.strip()]
        else:
            continue

        # If the section does not exist in the original configuration, create it
        if section not in clean_output_dict:
            raise ValueError(f"Section '{section}' not found in the original configuration file. There may be a typo.")

        # For each line in "key=value" format, parse the key-value pair and update the configuration
        for line in lines:
            # Ignore lines that start with '#' or do not contain '='
            if line.startswith("#") or "=" not in line:
                continue

            key, new_val = line.split("=", 1)
            key = key.strip()
            new_val = new_val.strip()

            # For the DBOptions section, if the key belongs to db_bench arguments, update only args_dict
            if section == "DBOptions" and key in DB_BENCH_ARGS:
                # If the value is "-1", skip the update
                if new_val == "-1":
                    continue
                if args_dict.get(key) != new_val:
                    print("Section: DBOptions")
                    print(f"Updating {key} from {args_dict.get(key)} to {new_val}")
                    args_dict[key] = new_val
                    changed_value[key] = new_val
                # Skip updating the file for db_bench parameters
                continue

            # For regular configuration options, update if the key does not exist or the value is different
            original_val = clean_output_dict[section].get(key)
            if original_val != new_val:
                print(f"Section: {section}")
                print(f"Updating {key} from {original_val} to {new_val}")
                clean_output_dict[section][key] = new_val
                changed_value[key] = new_val

    # Convert the updated dictionary into a ConfigParser object, then into an ini-formatted string
    config_parser = dict_to_configparser(clean_output_dict)
    config_string = configparser_to_string(config_parser)
    
    # Update db_bench arguments based on structured change
    if changed_db_bench_args is not None:
        logger.info("Updating db_bench based on structured change")
        db_bench_change_flag = False
        for key, value in dict(changed_db_bench_args).items():
            if value is not None:
                if args_dict.get(key) != value:
                    db_bench_change_flag = True
                    args_dict[key] = value
                    logger.info(f"Updating db_bench {key} to {value}")
        if not db_bench_change_flag:
            logger.info("No changes in db_bench based on structured change")

    # Generate the new bench arguments list
    new_bench_args = [f"--{k}={v}" for k, v in args_dict.items()]

    # Write the updated configuration to the specified file
    with open(opt_file_path, "w") as file:
        file.write(config_string)
        
    return config_string, changed_value, new_bench_args


def parse_db_bench_args_to_dict(db_bench_args):
    '''
    Function to parse the db_bench arguments to a dictionary

    Parameters:
    - db_bench_args (list): The db_bench arguments

    Returns:
    - parsed (dict): A dictionary containing the parsed data
    '''
    parsed = {}
    if db_bench_args is not None:
        for db_bench_arg in db_bench_args:
            key, value = db_bench_arg.strip().strip("--").split("=")
            parsed[key] = value
    return parsed

def get_initial_options_file():
    '''
    Get the initial options file

    Parameters:
    - None

    Returns:
    - options (str): The initial options file
    - reasoning (str): The reasoning behind the options file
    '''
    initial_options_file_path = os.path.join(DEFAULT_OPTION_FILE_DIR,
                                        INITIAL_OPTIONS_FILE_NAME)
    with open(initial_options_file_path, "r") as f:
        options = f.read()

    reasoning = f"Initial options file: {initial_options_file_path}"

    return options, reasoning


def parse_option_file_to_dict(option_file):
    '''
    Function to parse the given option file to a dictionary

    Parameters:
    - option_file (str): The path to the option file

    Returns:
    - parsed (dict): A dictionary containing the parsed data
    '''
    pat = re.compile("(.*)\s*([#].*)?")
    config = configparser.ConfigParser()
    config.read_string(option_file)
    parsed = {section: dict(config.items(section))
              for section in config.sections()}
    for section_name, section in parsed.items():
        for k, v in section.items():
            m = pat.match(v)
            section[k] = m[1]
    return parsed


